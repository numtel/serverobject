{"version":3,"file":"/packages/serverobject.js","sources":["serverobject/serverobject.js","serverobject/serverobject-server.js"],"names":[],"mappings":";;;;;;;;AAAA,4B;AACA,yE;AACA,qD;AACA,oB;AACA,6C;AACA,E;AACA,sC;AACA,8C;AACA,uD;AACA,yD;AACA,yD;AACA,mD;AACA,yE;AACA,iD;AACA,M;AACA,wB;AACA,mE;AACA,G;AACA,G;;AAEA,wB;;AAEA,iC;AACA,kB;;AAEA,8B;AACA,qB;AACA,+B;AACA,qB;AACA,M;AACA,I;;AAEA,oB;AACA,8B;AACA,wC;AACA,iC;AACA,M;AACA,I;;AAEA,sB;AACA,yC;;AAEA,8C;AACA,kC;AACA,yD;AACA,gC;AACA,oE;AACA,+C;AACA,Q;;AAEA,0C;AACA,+B;AACA,2B;AACA,8D;AACA,sC;AACA,mC;AACA,oE;AACA,U;AACA,S;;AAEA,2C;AACA,uC;AACA,2B;AACA,kB;AACA,iC;AACA,oC;AACA,2C;AACA,U;AACA,kB;AACA,0B;AACA,iB;AACA,U;;AAEA,6D;AACA,wC;AACA,2B;AACA,uC;AACA,Y;AACA,W;;AAEA,qC;;AAEA,qB;AACA,6C;AACA,U;AACA,S;AACA,M;AACA,K;AACA,E;;AAEA,iC;AACA,2B;AACA,4E;AACA,I;AACA,qD;AACA,qC;AACA,2C;AACA,I;AACA,0E;AACA,c;AACA,sB;AACA,a;AACA,M;AACA,gC;AACA,qC;;AAEA,kC;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;;AC5GA,oC;AACA,qB;AACA,+B;AACA,iD;AACA,wE;AACA,Q;AACA,wC;AACA,M;AACA,I;AACA,E;;AAEA,0B;;AAEA,mB;;AAEA,wC;AACA,kB;AACA,yB;AACA,qC;AACA,4B;AACA,0C;AACA,8B;AACA,M;AACA,I;AACA,gB;AACA,E;AACA,yC;AACA,kB;AACA,mC;AACA,oD;AACA,qB;AACA,M;AACA,I;AACA,gB;AACA,E;;AAEA,gB;AACA,qC;AACA,0D;;AAEA,wD;AACA,uE;AACA,M;;AAEA,iD;AACA,yE;AACA,uD;AACA,gC;;AAEA,0C;AACA,8C;;AAEA,qD;AACA,4C;AACA,M;;;AAGA,gD;AACA,mC;AACA,M;AACA,oD;;AAEA,Y;AACA,sB;AACA,uC;AACA,wC;AACA,M;AACA,I;AACA,4C;AACA,yE;AACA,iC;AACA,qE;AACA,M;AACA,uD;AACA,kB;AACA,4D;AACA,M;;AAEA,uB;;AAEA,oC;AACA,oE;AACA,wE;AACA,qC;AACA,sC;AACA,sD;AACA,mC;AACA,8B;AACA,gE;AACA,oD;AACA,mB;AACA,8B;AACA,+C;AACA,iD;AACA,a;AACA,W;AACA,Q;AACA,O;;AAEA,uB;AACA,Q;AACA,gF;AACA,kB;AACA,oC;AACA,uB;AACA,uC;AACA,+B;AACA,Y;AACA,kC;AACA,Q;AACA,M;;AAEA,Y;AACA,qB;AACA,qB;AACA,qB;AACA,2B;AACA,uC;AACA,wC;AACA,M;AACA,I;AACA,iD;AACA,yE;AACA,qD;AACA,6C;AACA,uC;AACA,M;AACA,G;AACA,G;;AAEA,0B;AACA,mC;AACA,G;;AAEA,oD;AACA,qE;AACA,qE;AACA,6D;AACA,mC;AACA,M;AACA,gE;AACA,G","sourcesContent":["var global = this || window;\nServerObjectCallbacks = new Meteor.Collection('_ServerObject_callbacks');\nglobal.ServerObjectCallbacks = ServerObjectCallbacks;\nif(Meteor.isClient){\n  Meteor.subscribe('ServerObject_callbacks');\n};\nServerObjectCallbacks.find().observe({\n  changed: function(newCallback, oldCallback){\n    if(readyCallbacks.hasOwnProperty(newCallback._id)){\n      var thisCallback = readyCallbacks[newCallback._id];\n      updateObj.call(thisCallback.instance, newCallback);\n      var argsArray = Object.keys(newCallback.args)\n                        .map(function(k) { return newCallback.args[k] });\n      thisCallback.func.apply(global, argsArray);\n    };\n    // Remove from queue\n    Meteor.call('_ServerObject_callbackReceived', newCallback._id);\n  }\n});\n\nvar readyCallbacks = {};\n\nvar updateObj = function(result){\n  var that = this;\n\n  // Remove old values/methods\n  for(var i in this){\n    if(this.hasOwnProperty(i)){\n      delete this[i];\n    };\n  };\n\n  // Copy new values\n  for(var i in result.values){\n    if(result.values.hasOwnProperty(i)){\n      this[i] = result.values[i];\n    };\n  };\n\n  this.prototype = {};\n  this.prototype.instanceKey = result.id;\n\n  result.methods.forEach(function(methodName){\n    that[methodName] = function(){\n      var callback = Array.prototype.pop.call(arguments);\n      // Check for main callback\n      if(callback !== undefined  && typeof callback !== 'function'){\n        throw new Error('Must pass callback.');\n      };\n\n      // Transcribe any callback arguments\n      var otherCallbacks = [], \n          args = arguments;\n      Array.prototype.forEach.call(args, function(arg, index){\n        if(typeof arg === 'function'){\n          otherCallbacks.push(arg);\n          args[index] = '##CALLBACK:' + (otherCallbacks.length - 1);\n        };\n      });\n\n      Meteor.call('_ServerObject_method', {\n        id: that.prototype.instanceKey,\n        method: methodName,\n        args: args\n      }, function(error, result){\n        if(result && result.errVal){\n          error = new Error(result.errVal);\n        };\n        if(error){\n          callback(error);\n          return;\n        };\n\n        result.callbacks.forEach(function(callbackId, index){\n          readyCallbacks[callbackId] = {\n            instance: that,\n            func: otherCallbacks[index]\n          };\n        });\n\n        updateObj.call(that, result);\n\n        if(callback){\n          callback(undefined, result.retVal);\n        };\n      });\n    };\n  });\n};\n\nglobal.ServerObject = function(){\n  if(arguments.length < 2){\n    throw new Error('Must pass object identifier key string and callback.');\n  };\n  var callback = Array.prototype.pop.call(arguments);\n  if(typeof callback !== 'function'){\n    throw new Error('Must pass callback.');\n  };\n  Meteor.apply('_ServerObject_create', arguments, function(error, result){\n    if(error){\n      callback(error);\n      return;\n    };\n    var instance = new Object();\n    updateObj.call(instance, result);\n\n    callback(undefined, instance);\n  });\n};\n\n","ServerObject.allow = function(objs){\n  for(var i in objs){\n    if(objs.hasOwnProperty(i)){\n      if(ServerObject.allowed.hasOwnProperty(i)){\n        throw new Error('ServerObject identifier already exists: ' + i);\n      };\n      ServerObject.allowed[i] = objs[i];\n    };\n  };\n};\n\nServerObject.allowed = {};\n\nvar instances = {};\n\nvar instanceValues = function(instance){\n  var output = {};\n  for(var i in instance){\n    if(instance.hasOwnProperty(i) && \n       i !== 'prototype' && \n       typeof instance[i] !== 'function'){\n      output[i] = instance[i];\n    };\n  };\n  return output;\n};\nvar instanceMethods = function(instance){\n  var output = [];\n  for(var i in instance.prototype){\n    if(typeof instance.prototype[i] === 'function'){\n      output.push(i);\n    };\n  };\n  return output;\n};\n\nMeteor.methods({\n  '_ServerObject_create': function(){\n    var objectKey = Array.prototype.shift.call(arguments);\n\n    if(!ServerObject.allowed.hasOwnProperty(objectKey)){\n      throw new Error('Invalid ServerObject identifier: ' + objectKey);\n    };\n\n    var objDef = ServerObject.allowed[objectKey],\n        connectionId = (this.connection ? this.connection.id : 'server'),\n        instanceKey = connectionId + ':' + Random.id(),\n        instance = new Object();\n\n    objDef.ref.apply(instance, arguments);\n    instance.prototype = objDef.ref.prototype;\n\n    if(objDef.where && !objDef.where.call(instance)){\n      throw new Error('Permission denied!');\n    };\n\n\n    if(!instances.hasOwnProperty(connectionId)){\n      instances[connectionId] = {};\n    };\n    instances[connectionId][instanceKey] = instance;\n\n    return {\n      id: instanceKey,\n      values: instanceValues(instance),\n      methods: instanceMethods(instance)\n    };\n  },\n  '_ServerObject_method': function(options){\n    var connectionId = (this.connection ? this.connection.id : 'server');\n    if(!instances[connectionId]){\n      throw new Error('No available instances for this connection.');\n    };\n    var instance = instances[connectionId][options.id];\n    if(!instance){\n      throw new Error('Invalid instance id: ' + options.id);\n    };\n\n    var callbacks = [];\n\n    // Handle any callback functions\n    Array.prototype.forEach.call(options.args, function(arg, index){\n      if(typeof arg === 'string' && arg.substr(0,11) === '##CALLBACK:'){\n        var callbackId = Random.id();\n        ServerObjectCallbacks.insert({\n          _id: callbackId, connection: connectionId});\n        callbacks.push(callbackId);\n        // Transitory callback\n        options.args[index] = Meteor.bindEnvironment(function(){\n          ServerObjectCallbacks.update(callbackId, {\n            $set: {\n              args: arguments,\n              values: instanceValues(instance),\n              methods: instanceMethods(instance)}\n          });\n        });\n      };\n    });\n\n    var retVal, errVal;\n    try{\n      retVal = instance.prototype[options.method].apply(instance, options.args);\n    }catch(error){\n      if(typeof error === 'string'){\n        errVal = error;\n      }else if(error instanceof Error){\n        errVal = error.message;\n      }else{\n        errVal = error.toString();\n      };\n    };\n\n    return {\n      id: options.id,\n      retVal: retVal,\n      errVal: errVal,\n      callbacks: callbacks,\n      values: instanceValues(instance),\n      methods: instanceMethods(instance)\n    };\n  },\n  '_ServerObject_callbackReceived': function(id){\n    var connectionId = (this.connection ? this.connection.id : 'server');\n    var callback = ServerObjectCallbacks.findOne(id);\n    if(callback.connection === connectionId){\n      ServerObjectCallbacks.remove(id);\n    };\n  }\n});\n\nMeteor.startup(function(){\n  ServerObjectCallbacks.remove({});\n});\n\nMeteor.publish('ServerObject_callbacks', function(){\n  var connectionId = this.connection ? this.connection.id : 'server';\n  this._session.socket.on(\"close\", Meteor.bindEnvironment(function(){\n    ServerObjectCallbacks.remove({connection: connectionId});\n    delete instances[connectionId];\n  }));\n  return ServerObjectCallbacks.find({connection: connectionId});\n});\n\n"]}